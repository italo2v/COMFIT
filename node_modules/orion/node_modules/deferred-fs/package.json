{
  "name": "deferred-fs",
  "version": "0.3.2",
  "description": "Provides a promise-based API for Node's filesystem APIs.",
  "main": "index.js",
  "directories": {
    "lib": "lib",
    "test": "test"
  },
  "scripts": {
    "test": "mocha --reporter spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mamacdon/deferred-fs.git"
  },
  "keywords": [
    "promise",
    "deferred",
    "node",
    "fs",
    "orion"
  ],
  "author": {
    "name": "Orion contributors"
  },
  "license": "EPL+EDL",
  "devDependencies": {
    "mocha": "*"
  },
  "readme": "# deferred-fs\r\n\r\nProvides a promise-based API for Node.js's [filesystem API](http://nodejs.org/api/fs.html).\r\n\r\n## Requirements\r\nNode.js\r\n\r\n## Installation\r\n\r\nThe easiest way is to install deferred-fs using npm, like this:\r\n\r\n```\r\n$ npm install deferred-fs\r\n```\r\n\r\nThis will install deferred-fs into your project's ```node_modules``` subdirectory. From a Node app, you can then load dfs by doing ```require('deferred-fs')```.\r\n\r\n## Deferred-fs API\r\n\r\nThe object returned by ```require('deferred-fs')``` works exactly like Node's ```fs``` library, except that its asynchronous methods return a promise object instead of accepting a callback argument.\r\n\r\nHere's an example showing how to use ```writeFile``` to asynchronously write a file and print a completion message when done:\r\n\r\n```js\r\nvar dfs = require('dfs');\r\ndfs.writeFile('hello.txt', 'Hello world!', 'utf8').then(\r\n    function () {\r\n        console.log('File was written successfully.');\r\n    });\r\n```\r\n\r\nIn cases where a normal callback would return an \"error\" argument, the returned promise *rejects*, meaning the second callback is invoked:\r\n\r\n```js\r\nvar dfs = require('dfs');\r\ndfs.readFile('/file_that_does_not_exist').then(\r\n\tnull,\r\n    function (error) {\r\n        console.log('Yikes, an error occurred! ' + error);\r\n    });\r\n```\r\n\r\nThe above program will output:\r\n\r\n```\r\nYikes, an error occurred! Error: ENOENT, open 'c:\\file_that_does_not_exist'\r\n```\r\n\r\nThe real advantage of the promise approach comes from chaining promises together, allowing you to transform values returned by earlier callbacks\r\nand implement high-level error handling.\r\n\r\n## Promise API\r\nThe promise object returned by deferred-fs's asynchronous methods has the familiar \"then\" API:\r\n\r\n* ```then(onResolve, onReject)```\r\n\r\nInternally these promises are implemented using the Deferred library from [Eclipse Orion](http://eclipse.org/orion). This means they're 100% compliant with the [Promises/A+ specification](https://github.com/promises-aplus/promises-spec), version 1.1.\r\n\r\n## Deferred API\r\ndeferred-fs also exports Orion's Deferred library, giving you access to a richer API than simple promises:\r\n\r\n```js\r\nvar Deferred = require('deferred-fs').Deferred;\r\n\r\nvar promises = [ new Deferred().resolve('resolved!'), new Deferred().reject('rejected :(') ];\r\nDeferred.all(promises).then(\r\n  function(results) {\r\n    console.log('All promises resolved: ' + results.join(', '));\r\n  }, function(err) {\r\n    console.log('An error occurred: ' + err);\r\n  });\r\n```\r\n\r\nConsult the [Deferred JSDoc](https://orionhub.org/jsdoc/symbols/orion.Deferred.html) for details of the available API methods. In addition to Promises/A+ compliance,\r\nOrion's Deferred also implements some evolving APIs like [progress](https://github.com/promises-aplus/progress-spec) and \r\n[cancellation](https://github.com/promises-aplus/cancellation-spec).\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mamacdon/deferred-fs/issues"
  },
  "_id": "deferred-fs@0.3.2",
  "_from": "deferred-fs@~0.3.2"
}
